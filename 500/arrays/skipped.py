# 3. extension of 2, Print all sub-arrays with 0 sum
# 10. inplace merge sort, nothing good
# 11. okay okay, come back if time
# 13. only trick is to find, max and second max (same for mins) in O(n)
# 14. shit problem
# 15. shit
# 18. quicksort variation
# 20. dumb version of LIS, this one is subarray so continuous elements
# 23. kadanes' print variation, skip
# 24. weird question, skip for now, just a kadanes' variation
# 26. dumb variation of 25
# 28. variation of 27, sliding window, here window is of size k, much easier
# 29. hashing or sliding window
# 32. basic
# 37. reverse lis array
# 38. bit weird, come back if time
# 39. min platforms needed, already solved
# 42. dumb
# 44. weird and went bouncer, come back if time
# 46, 47, shit
# 48. variation of sum pair, somewhat same approach of hashing, only diff is check for both (i+diff), (i-diff)
# 49. filler
# 50. little variation of 43, triplets
# 51. print extended, come back to this if time, for practice
# 52. hashmap or xor, good impl of xor, nothing good to code
# 53. good impl of xor, to find back original numbers, skip for now
# 54. quickselect (from quicksort) simple concept
# 56. similar to 55, gp instead of ap
# 58. dumb
# 59. simple, variation of sum triplets
# 60. Group elements of an array based on their first occurrence - simple hash, count and print
# 61. shit problem
# 62. good for coding, and simple appl of kadane's , come back if time
# 63. find pairs like {4, 3} | {3, 4}, simple hashing
# ##65, debugs
# 66. simple observation, skip
# 68. simple observation,max product triplet, last three elements or First two element&last element of the sorted array
# 69. come back to dp version, good problem
# 70. simple problem, only catch is last to first traversal
# 72. simple
# 73. default dict with list impl
# 74. dumb que
# 75. dumb que
# 76. simple observation
## 77, come back at eod
# 79. dumb
# 80. space optimization
# 82. duplicate of 25
# 83 duplicate of 29, hashing and sum subarray
## 84. opp of inversion count, merge sort alg, good fro practice, come back on this
# 85. duplicate of 12, continuos ones
# 86. duplicate of 12, continuos ones
# 87. merging overalpping intervals, like min platforms que, print vn count==0 and arr prior dep, via stack on blog
# 88. job scheduling, greedy
# 89. deadline job scheduling, covered in dp
# 90-94. reading articles, min/max heaps
# 95. trick question , building maxHeap is O(n) not O(nlgn)
# 96. good for max/min heap O analysis, O(n + klogn) vs O(nlogk)
# 97. Sort a K-Sorted Array, skip
# 98. Merge M sorted lists of variable length, heap implementation, just take a look
# 99. kth smallest element
# 101-109 articles, skip
## 110. Hoareâ€™s vs Lomuto partition scheme in QuickSort . read, implement if time //gfg
## 111. External merge sort, do not implement, read, https://www.youtube.com/watch?v=Bp7fGofslng
# 112. shit que
# 113. custom sort, based on conditions, come back if time, good for python practice
# 114. Inversion Count of an array, skip
# 115. shit que
# 116-119. shit articles, skip
# 120 , covered
# 121, come back if time, coding practice and revision
# 122, 123, covered, take a look, code if time, simple binary search problems, lil diff
# 124, 126, 127, 128 dumb que, all binary sort variations
# 125. covered, floor, ceil binary search
# 129. kadanes
# 130. not good
# 131-140. DP problems, covered
##141. good problem, code if time, bt application
## 143. All combinations of elements satisfying given constraints, come back if time, coding practice, recusrsion
# 144. binary search application, just take a quick look
# 145, 146, 147. skip

##148. parked, 149, 150 similar
# 151-156. skip, covered in dp
